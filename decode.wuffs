packageid "zstd"

pub struct decoder?(
)

pub error "not a frame"
pub error "frame reserved bit was set"
pub error "reserved block type found"
pub error "block size is larger than 128KiB"
pub error "block size is larger than window size"

pub error "TODO"

pub func decoder.decode?(dst base.io_writer, src base.io_reader)() {
	while in.src.available() > 0 {
		var z base.status = try this.decode_frame?(dst:in.dst, src:in.src)
		if z.is_suspension() {
			yield z
		}
		if z.is_error() {
			return z
		}
	}
}

pri func decoder.decode_frame?(dst base.io_writer, src base.io_reader)() {
	var magic base.u32 = in.src.read_u32le?()
	if (magic >= frame_magic_skip_first) and (magic <= frame_magic_skip_last) {
		var frame_size base.u32 = in.src.read_u32le?()
		in.src.skip32?(n:frame_size)
		return
	}
	if magic != frame_magic_number {
		return error "not a frame"
	}

	var frame_header base.u8 = in.src.read_u8?()

	var fcs_flag base.u8[..0x3] = frame_header >> 6
	var fcs_field_size base.u8 = fcs_field_sizes[fcs_flag]

	var single_segment base.bool = ((frame_header >> 5) & 1) == 1
	if (fcs_flag == 0) and single_segment {
		fcs_field_size = 1
	}

	var frame_cont_size base.u64
	if fcs_field_size == 1 {
		frame_cont_size = in.src.read_u8?() as base.u64
	} else if fcs_field_size == 2 {
		frame_cont_size = (in.src.read_u16le?() as base.u64) + 256
	} else if fcs_field_size == 4 {
		frame_cont_size = in.src.read_u32le?() as base.u64
	} else if fcs_field_size == 8 {
		frame_cont_size = in.src.read_u64le?()
	} else {
		return error "TODO" // prove this can't happen?
	}

	var window_size base.u64 = min_window_size
	if not single_segment {
		return error "TODO"
	} else {
		window_size = frame_cont_size
	}

	if ((frame_header >> 3) & 1) == 1 {
		return error "frame reserved bit was set"
	}

	var hashing base.bool = ((frame_header >> 2) & 1) == 1

	var dict_id_flag base.u8 = frame_header & 3
	if dict_id_flag > 0 {
		return error "TODO" // read and use dictionary ID
	}

	while true {
		var block_header base.u32[..0xFFFFFF] = in.src.read_u24le?()

		var is_last_block base.bool = (block_header & 1) == 1
		var block_type base.u8[..0x3] = ((block_header >> 1) & 3) as base.u8

		var block_size base.u32[..0x1FFFFF] = block_header >> 3
		if block_size > max_block_size {
			return error "block size is larger than 128KiB"
		}
		if (block_size as base.u64) > window_size {
			return error "block size is larger than window size"
		}

		var b base.u8
		if block_type == block_type_raw {
			in.dst.copy_from_reader32!(r:in.src, length:block_size)
		} else if block_type == block_type_rle {
			b = in.src.read_u8?()
			var i base.u32
			while i < block_size,
				inv max_block_size == 131072,
				inv block_size <= max_block_size {

				// TODO: hopefully clean up once this issue is
				// fixed: https://github.com/google/wuffs/issues/11
				assert i <= max_block_size via "a <= b: a <= c; c <= b"(c:block_size)
				assert i <= 131072 via "a <= b: a <= c; c == b"(c: max_block_size)

				in.dst.write_u8?(x:b)
				i += 1
			}
		} else if block_type == block_type_compressed {
			return error "TODO"
		} else {
			return error "reserved block type found"
		}
		if is_last_block {
			break
		}
	}
	if hashing {
		var sum base.u32 = in.src.read_u32le?()
		// TODO: check the hash
	}
}
