packageid "zstd"

pub struct decoder?(
)

pub error "not a frame"
pub error "frame reserved bit was set"
pub error "reserved block type found"
pub error "block size is larger than 128KiB"
pub error "block size is larger than window size"

pub error "TODO"

pub func decoder.decode?(dst writer1, src reader1)() {
	var magic u32 = in.src.read_u32le?()
	if magic != frame_magic_number {
		return error "not a frame"
	}

	var frame_header u8 = in.src.read_u8?()

	var fcs_flag u8[..0x3] = frame_header >> 6
	var fcs_field_size u8 = fcs_field_sizes[fcs_flag]

	var single_segment bool = ((frame_header >> 5) & 1) == 1
	if (fcs_flag == 0) and single_segment {
		fcs_field_size = 1
	}

	var frame_cont_size u64
	if fcs_field_size == 1 {
		frame_cont_size = in.src.read_u8?() as u64
	} else if fcs_field_size == 2 {
		frame_cont_size = (in.src.read_u16le?() as u64) + 256
	} else if fcs_field_size == 4 {
		frame_cont_size = in.src.read_u32le?() as u64
	} else if fcs_field_size == 8 {
		// TODO: read_u64le doesn't seem to compile
	} else {
		// TODO: prove this can't happen?
	}

	var window_size u64 = min_window_size
	if not single_segment {
		return error "TODO"
	} else {
		window_size = frame_cont_size
	}

	if ((frame_header >> 3) & 1) == 1 {
		return error "frame reserved bit was set"
	}

	var hashing bool = ((frame_header >> 2) & 1) == 1
	// TODO: do the hashing

	// TODO: possibly read dictionary ID

	while true {
		// spaghetti code to read a three-byte little endian number
		var block_lower u32[..0xFF] = in.src.read_u8?() as u32
		var block_upper u32[..0xFFFF] = in.src.read_u16le?() as u32
		var block_header u32[..0xFFFFFF] = (block_upper << 8) | block_lower

		var is_last_block bool = (block_header & 1) == 1

		var block_type u8[..0x3] = ((block_header >> 1) & 3) as u8

		var block_size u32[..0x1FFFFF] = block_header >> 3
		if block_size > 131072 {
			return error "block size is larger than 128KiB"
		}
		if (block_size as u64) > window_size {
			return error "block size is larger than window size"
		}

		var b u8
		if block_type == block_type_raw {
			in.dst.copy_from_reader32(r:in.src, length:block_size)
		} else if block_type == block_type_rle {
			b = in.src.read_u8?()
			var i u32
			while i < block_size, inv block_size <= 131072 {
				assert i <= 131072 via "a <= b: a <= c; c <= b"(c:block_size)
				in.dst.write_u8?(x:b)
				i += 1
			}
		} else if block_type == block_type_compressed {
			return error "TODO"
		} else {
			return error "reserved block type found"
		}
		if is_last_block {
			break
		}
	}
}
